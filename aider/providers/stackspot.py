"""StackSpot AI provider implementation."""

import asyncio
import os
import time
from typing import Dict, List, Optional

import httpx
from pydantic import BaseModel, Field


class StackSpotCommand(BaseModel):
    """Base model for StackSpot commands."""

    name: str = Field(default="create-remote-qc")
    command: str = Field(alias="slug")
    description: str = "Generated by Aider"
    content: str
    model_type: str = "code"


class StackSpotResponse(BaseModel):
    """StackSpot response model."""

    id: str = Field(default_factory=lambda: f"ssp-{int(time.time())}")
    content: str
    metadata: Optional[Dict] = None


class StackSpotProvider:
    """Provider for StackSpot AI integration."""

    def __init__(self):
        """Initialize the provider."""
        self.api_key = os.getenv("STACKSPOT_API_KEY")
        if not self.api_key:
            raise ValueError(
                "STACKSPOT_API_KEY environment variable not set. Please set it with a valid API key."
            )

        # Validate API key format
        if not self._validate_api_key(self.api_key):
            raise ValueError(
                "Invalid STACKSPOT_API_KEY format. Please ensure it starts with 'sk_stackspot_' "
                "and contains a valid key string. Example: sk_stackspot_123..."
            )

        self.api_base = "https://genai-code-buddy-api.stackspot.com"
        self.timeout = 60.0
        self.max_retries = 3
        self.retry_delay = 1.0
        self.http_client = httpx.AsyncClient(
            timeout=self.timeout,
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),
            http2=True,
        )

    def _validate_api_key(self, api_key: str) -> bool:
        """Validate the API key format."""
        if not api_key:
            return False

        valid_prefixes = ("sk_stackspot_", "sk_test_stackspot_")
        has_valid_prefix = any(api_key.startswith(prefix) for prefix in valid_prefixes)
        has_valid_length = len(api_key) >= 32  # Minimum key length

        return has_valid_prefix and has_valid_length

    def _get_headers(self) -> Dict[str, str]:
        """Return headers for requests."""
        return {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json",
            "User-Agent": "aider/1.0",
        }

    def _prepare_command(
        self, messages: List[Dict[str, str]], model_type: str = "code"
    ) -> StackSpotCommand:
        """Prepare command for sending."""
        if not messages:
            raise ValueError("No messages provided for completion")

        content = messages[-1].get("content")
        if not content:
            raise ValueError("Message content is empty or invalid")

        return StackSpotCommand(
            slug=f"aider-{int(time.time())}",
            content=content,
            model_type=model_type,
        )

    def _format_response(self, stackspot_response: Dict) -> Dict:
        """Format response according to market standards."""
        if not stackspot_response or not isinstance(stackspot_response, dict):
            raise ValueError("Invalid response format from StackSpot API")

        content = stackspot_response.get("content")
        if not content:
            raise ValueError("No content in StackSpot response")

        response = StackSpotResponse(
            content=content,
            metadata=stackspot_response.get("metadata"),
        )

        return {
            "id": response.id,
            "object": "chat.completion",
            "created": int(time.time()),
            "model": "stackspot-ai",
            "choices": [
                {
                    "index": 0,
                    "message": {"role": "assistant", "content": response.content},
                    "finish_reason": "stop",
                }
            ],
            "usage": {
                "prompt_tokens": len(str(response.content).split()),
                "completion_tokens": len(response.content.split()),
                "total_tokens": len(str(response.content).split())
                + len(response.content.split()),
            },
        }

    async def _make_request(self, url: str, method: str = "GET", **kwargs) -> Dict:
        """Make HTTP request with retries."""
        last_error = None
        for attempt in range(self.max_retries):
            try:
                if method == "GET":
                    response = await self.http_client.get(url, **kwargs)
                else:
                    response = await self.http_client.post(url, **kwargs)

                if response.status_code == 401:
                    raise ValueError(
                        "Invalid API key or unauthorized access. Please check your STACKSPOT_API_KEY."
                    )
                elif response.status_code == 403:
                    raise ValueError(
                        "API key does not have permission to access this resource. "
                        "Please ensure you're using a valid API key with appropriate permissions."
                    )
                elif response.status_code == 429:
                    retry_after = int(
                        response.headers.get("Retry-After", self.retry_delay)
                    )
                    print(f"Rate limit exceeded. Retrying in {retry_after} seconds...")
                    await asyncio.sleep(retry_after)
                    continue

                response.raise_for_status()
                return response.json()

            except httpx.HTTPError as e:
                last_error = e
                if response.status_code in (401, 403):
                    raise ValueError(str(e))
                if attempt == self.max_retries - 1:
                    raise Exception(
                        f"HTTP error after {self.max_retries} attempts: {str(e)}"
                    )
                await asyncio.sleep(self.retry_delay * (attempt + 1))

            except Exception as e:
                last_error = e
                if attempt == self.max_retries - 1:
                    raise Exception(
                        f"Error making request after {self.max_retries} attempts: {str(e)}"
                    )
                await asyncio.sleep(self.retry_delay * (attempt + 1))

        raise last_error

    async def completion(
        self,
        messages: List[Dict[str, str]],
        model: str = "stackspot-ai",
        temperature: float = 0.7,
        max_tokens: Optional[int] = None,
        stream: bool = False,
        **kwargs,
    ) -> Dict:
        """Execute a completion request."""
        try:
            model_type = kwargs.get("model_type", "code")
            command = self._prepare_command(messages, model_type)

            # Create execution
            execution_data = await self._make_request(
                f"{self.api_base}/v1/quick-commands/create-execution/{command.command}",
                method="POST",
                headers=self._get_headers(),
                json=command.model_dump(by_alias=True),
            )

            if not execution_data or "execution_id" not in execution_data:
                raise ValueError("Invalid response from create execution endpoint")

            execution_id = execution_data["execution_id"]
            max_status_checks = 60  # 1 minute with 1 second intervals

            # Monitor execution status
            for check in range(max_status_checks):
                status_data = await self._make_request(
                    f"{self.api_base}/v1/quick-commands/callback/{execution_id}",
                    headers=self._get_headers(),
                )

                if not status_data or "status" not in status_data:
                    raise ValueError("Invalid response from callback endpoint")

                if status_data["status"] == "completed":
                    if "result" not in status_data:
                        raise ValueError("No result in completed status response")
                    return self._format_response(status_data["result"])
                elif status_data["status"] == "failed":
                    error_msg = status_data.get("error", "Unknown error")
                    raise Exception(f"Execution failed: {error_msg}")
                elif status_data["status"] == "unauthorized":
                    raise ValueError(
                        "Unauthorized: Invalid API key. Please check your STACKSPOT_API_KEY."
                    )
                elif status_data["status"] == "processing":
                    if check % 10 == 0:  # Log every 10 checks
                        print(
                            f"Request still processing... ({check + 1}/{max_status_checks})"
                        )

                await asyncio.sleep(1)

            raise Exception("Execution timed out after 60 seconds")

        except ValueError as e:
            raise ValueError(f"StackSpot API Error: {str(e)}")
        except Exception as e:
            raise Exception(f"Error in StackSpot completion: {str(e)}")

    async def close(self):
        """Close the HTTP client."""
        await self.http_client.aclose()

    def __del__(self):
        """Cleanup when destroying the object."""
        try:
            asyncio.run(self.close())
        except Exception:
            pass
