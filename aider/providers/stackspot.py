"""StackSpot AI provider implementation."""

import asyncio
import os
import time
from typing import Dict, List, Optional

import httpx
from pydantic import BaseModel, ConfigDict, Field

from ..conversation_manager import ConversationManager
from .stackspot_config import configure_stackspot


class StackSpotCommand(BaseModel):
    """Base model for StackSpot commands."""

    model_config = ConfigDict(populate_by_name=True)

    name: str = Field(default="create-remote-qc")
    command: str = Field(alias="slug")
    description: str = "Generated by Aider"
    content: str
    model_type: str = "code"
    conversation_id: Optional[str] = None


class StackSpotResponse(BaseModel):
    """StackSpot response model."""

    model_config = ConfigDict(populate_by_name=True)

    id: str = Field(default_factory=lambda: f"ssp-{int(time.time())}")
    content: str
    metadata: Optional[Dict] = None


class StackSpotProvider:
    """Provider for StackSpot AI integration."""

    def __init__(self, api_key=None):
        """Initialize the StackSpot provider.

        Args:
            api_key (str, optional): The API key for authentication. If not provided,
                will try to get from environment variable STACKSPOT_API_KEY.
        """
        if isinstance(api_key, list):
            # If api_key is a list from command line args, get the first one
            api_key = api_key[0]

        if api_key and "=" in api_key:
            # If api_key is in format "provider=key", extract the key
            api_key = api_key.split("=")[-1]

        if not api_key and "STACKSPOT_API_KEY" in os.environ:
            api_key = os.environ["STACKSPOT_API_KEY"]

        if not api_key:
            raise ValueError(
                "No API key provided. Please provide it via api_key parameter or "
                "STACKSPOT_API_KEY environment variable."
            )

        os.environ["STACKSPOT_API_KEY"] = api_key
        self.config = configure_stackspot()

        self.access_token = None
        self.token_expires_at = 0
        self.conversation_manager = ConversationManager()
        self.conversation_id = None

        self.timeout = 60.0
        self.max_retries = 3
        self.retry_delay = 1.0
        self.http_client = httpx.AsyncClient(
            timeout=self.timeout,
            limits=httpx.Limits(max_keepalive_connections=5, max_connections=10),
            http2=True,
        )

    async def _get_access_token(self) -> str:
        """Get a valid access token, refreshing if necessary."""
        now = time.time()
        if self.access_token and now < self.token_expires_at:
            return self.access_token

        auth_url = self.config["auth"]["auth_url"].format(
            realm=self.config["auth"]["realm"]
        )

        data = {
            "grant_type": "client_credentials",
            "client_id": self.config["auth"]["client_id"],
            "client_secret": self.config["auth"]["secret_key"],
        }

        try:
            response = await self.http_client.post(
                auth_url,
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"},
            )
            response.raise_for_status()

            token_data = response.json()
            self.access_token = token_data["access_token"]
            self.token_expires_at = now + token_data["expires_in"] - 60  # Buffer of 60s

            return self.access_token

        except Exception as e:
            raise ValueError(f"Failed to obtain access token: {str(e)}")

    def _get_headers(self) -> Dict[str, str]:
        """Return headers for requests."""
        return {
            "Authorization": f"Bearer {self.access_token}",
            "Content-Type": "application/json",
            "Accept": "application/json",
            "User-Agent": "aider/1.0",
        }

    def _prepare_command(
        self, messages: List[Dict[str, str]], model_type: str = "code"
    ) -> StackSpotCommand:
        """Prepare command for sending."""
        if not messages:
            raise ValueError("No messages provided for completion")

        content = messages[-1].get("content")
        if not content:
            raise ValueError("Message content is empty or invalid")

        return StackSpotCommand(
            slug=f"aider-{int(time.time())}",
            content=content,
            model_type=model_type,
            conversation_id=self.conversation_id,
        )

    async def _create_quick_command(self, command: StackSpotCommand) -> str:
        """Create a quick command and return its ID."""
        url = f"{self.config['api']['base_url']}{self.config['api']['quick_command_endpoint']}"

        access_token = await self._get_access_token()
        headers = self._get_headers()

        response = await self.http_client.post(
            url,
            headers=headers,
            json=command.model_dump(by_alias=True),
        )
        response.raise_for_status()

        data = response.json()
        return data["command_id"]

    async def _execute_command(self, command_id: str, model: str) -> Dict:
        """Execute a command and return its result."""
        url = f"{self.config['api']['base_url']}{self.config['api']['execution_endpoint']}".format(
            command_id=command_id
        )

        access_token = await self._get_access_token()
        headers = self._get_headers()

        response = await self.http_client.post(
            url,
            headers=headers,
            json={"model": model},
        )
        response.raise_for_status()

        data = response.json()
        return data

    async def _check_execution_status(self, execution_id: str) -> Dict:
        """Check the status of an execution."""
        url = f"{self.config['api']['base_url']}{self.config['api']['callback_endpoint']}".format(
            execution_id=execution_id
        )

        access_token = await self._get_access_token()
        headers = self._get_headers()

        response = await self.http_client.get(url, headers=headers)
        response.raise_for_status()

        return response.json()

    def _format_response(self, stackspot_response: Dict) -> Dict:
        """Format response according to market standards."""
        if not stackspot_response or not isinstance(stackspot_response, dict):
            raise ValueError("Invalid response format from StackSpot API")

        content = stackspot_response.get("content")
        if not content:
            raise ValueError("No content in StackSpot response")

        response = StackSpotResponse(
            content=content,
            metadata=stackspot_response.get("metadata"),
        )

        return {
            "id": response.id,
            "object": "chat.completion",
            "created": int(time.time()),
            "model": "stackspot-ai",
            "choices": [
                {
                    "index": 0,
                    "message": {"role": "assistant", "content": response.content},
                    "finish_reason": "stop",
                }
            ],
            "usage": {
                "prompt_tokens": len(str(response.content).split()),
                "completion_tokens": len(response.content.split()),
                "total_tokens": len(str(response.content).split())
                + len(response.content.split()),
            },
        }

    async def completion(
        self,
        messages: List[Dict[str, str]],
        model: str = "stackspot-ai",
        temperature: float = 0.7,
        max_tokens: Optional[int] = None,
        stream: bool = False,
        conversation_id: Optional[str] = None,
        **kwargs,
    ) -> Dict:
        """Execute a completion request."""
        try:
            # Get or create conversation
            if conversation_id:
                self.conversation_id = conversation_id
            elif not self.conversation_id:
                metadata = {
                    "model": model,
                    "temperature": temperature,
                    "first_message": messages[0]["content"] if messages else "",
                }
                self.conversation_id = self.conversation_manager.create_conversation(
                    metadata
                )

            # Update conversation metadata
            self.conversation_manager.update_conversation(
                self.conversation_id,
                {
                    "last_message": messages[-1]["content"] if messages else "",
                    "last_used": time.time(),
                },
            )

            model_type = kwargs.get("model_type", "code")
            command = self._prepare_command(messages, model_type)

            # Create quick command
            command_id = await self._create_quick_command(command)

            # Execute command
            execution_data = await self._execute_command(command_id, model)
            if not execution_data or "execution_id" not in execution_data:
                raise ValueError("Invalid response from create execution endpoint")

            execution_id = execution_data["execution_id"]
            max_status_checks = 60  # 1 minute with 1 second intervals

            # Monitor execution status
            for check in range(max_status_checks):
                status_data = await self._check_execution_status(execution_id)

                if not status_data or "status" not in status_data:
                    raise ValueError("Invalid response from callback endpoint")

                if status_data["status"] == "completed":
                    if "result" not in status_data:
                        raise ValueError("No result in completed status response")

                    # Update conversation with response
                    self.conversation_manager.update_conversation(
                        self.conversation_id,
                        {
                            "last_response": status_data["result"].get("content", ""),
                            "last_status": "completed",
                        },
                    )

                    return self._format_response(status_data["result"])

                elif status_data["status"] == "failed":
                    error_msg = status_data.get("error", "Unknown error")
                    self.conversation_manager.update_conversation(
                        self.conversation_id,
                        {"last_status": "failed", "last_error": error_msg},
                    )
                    raise Exception(f"Execution failed: {error_msg}")
                elif status_data["status"] == "unauthorized":
                    self.conversation_manager.update_conversation(
                        self.conversation_id, {"last_status": "unauthorized"}
                    )
                    raise ValueError(
                        "Unauthorized access. Please check your credentials."
                    )
                elif status_data["status"] == "processing":
                    if check % 10 == 0:  # Log every 10 checks
                        print(
                            f"Request still processing... ({check + 1}/{max_status_checks})"
                        )

                await asyncio.sleep(1)

            self.conversation_manager.update_conversation(
                self.conversation_id, {"last_status": "timeout"}
            )
            raise Exception("Execution timed out after 60 seconds")

        except ValueError as e:
            if self.conversation_id:
                self.conversation_manager.update_conversation(
                    self.conversation_id, {"last_status": "error", "last_error": str(e)}
                )
            raise ValueError(f"StackSpot API Error: {str(e)}")
        except Exception as e:
            if self.conversation_id:
                self.conversation_manager.update_conversation(
                    self.conversation_id, {"last_status": "error", "last_error": str(e)}
                )
            raise Exception(f"Error in StackSpot completion: {str(e)}")

    async def close(self):
        """Close the HTTP client."""
        await self.http_client.aclose()

    def __del__(self):
        """Cleanup when destroying the object."""
        try:
            asyncio.run(self.close())
        except Exception:
            pass
